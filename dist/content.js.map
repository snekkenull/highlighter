{"version":3,"file":"content.js","mappings":"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","sources":["webpack://highlighter/./src/utils/text-matcher.ts","webpack://highlighter/./src/content/content.ts"],"sourcesContent":["export class TextMatcher {\n    /**\n     * Finds the best matching position for a text segment within a larger text,\n     * using the approximate start and end positions as guidance.\n     */\n    static findBestMatch(text, approximateStart, approximateEnd) {\n        // Extract the target text using approximate positions\n        const approximateText = text.slice(Math.max(0, approximateStart), Math.min(text.length, approximateEnd));\n        // Define search boundaries with margin\n        const searchStart = Math.max(0, approximateStart - this.FUZZY_MARGIN);\n        const searchEnd = Math.min(text.length, approximateEnd + this.FUZZY_MARGIN);\n        let bestMatch = null;\n        let bestConfidence = 0;\n        // Slide through possible positions within the margin\n        for (let i = searchStart; i <= searchEnd - approximateText.length; i++) {\n            const candidateText = text.slice(i, i + approximateText.length);\n            const confidence = this.calculateSimilarity(approximateText, candidateText);\n            if (confidence > bestConfidence && confidence >= this.MIN_CONFIDENCE) {\n                bestMatch = {\n                    start: i,\n                    end: i + candidateText.length,\n                    confidence\n                };\n                bestConfidence = confidence;\n            }\n        }\n        return bestMatch;\n    }\n    /**\n     * Calculates the similarity between two strings using Levenshtein distance.\n     * Returns a score between 0 and 1, where 1 means exact match.\n     */\n    static calculateSimilarity(str1, str2) {\n        const len1 = str1.length;\n        const len2 = str2.length;\n        const matrix = [];\n        // Initialize matrix\n        for (let i = 0; i <= len1; i++) {\n            matrix[i] = [i];\n        }\n        for (let j = 0; j <= len2; j++) {\n            matrix[0][j] = j;\n        }\n        // Fill matrix\n        for (let i = 1; i <= len1; i++) {\n            for (let j = 1; j <= len2; j++) {\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion\n                matrix[i][j - 1] + 1, // insertion\n                matrix[i - 1][j - 1] + cost // substitution\n                );\n            }\n        }\n        // Calculate similarity score\n        const distance = matrix[len1][len2];\n        const maxLength = Math.max(len1, len2);\n        return 1 - distance / maxLength;\n    }\n}\nTextMatcher.FUZZY_MARGIN = 10; // Characters to check on each side\nTextMatcher.MIN_CONFIDENCE = 0.8; // Minimum confidence score\n","import { TextMatcher } from '../utils/text-matcher';\nlet settings;\nlet observer;\nlet processedElements = new Set();\nlet isHighlightingEnabled = false;\nlet isProcessing = false;\nconst API_RATE_LIMIT = 5000; // 5 seconds between API calls\nconst MAX_CACHE_SIZE = 100; // Maximum number of entries in highlight cache\nconst MAX_RETRIES = 3; // Maximum number of API request retries\nconst RETRY_DELAY = 1000; // Delay between retries in milliseconds\nlet highlightCache = new Map();\nlet requestQueue = [];\nlet isProcessingQueue = false;\nlet lastProcessedPosition = new Map();\n// Add CSS animation to the document\nconst style = document.createElement('style');\nstyle.textContent = `\n  @keyframes highlightFade {\n    from { background-color: transparent; }\n    to { background-color: #FFEB3B; }\n  }\n\n  @keyframes fadeIn {\n    from { opacity: 0; transform: translateY(10px); }\n    to { opacity: 1; transform: translateY(0); }\n  }\n\n  @keyframes fadeOut {\n    from { opacity: 1; transform: translateY(0); }\n    to { opacity: 0; transform: translateY(10px); }\n  }\n\n  .highlight-toast-container {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    z-index: 10000;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n  }\n\n  .highlight-toast {\n    background-color: #333;\n    color: white;\n    padding: 12px 20px;\n    border-radius: 4px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n    animation: fadeIn 0.3s ease-out;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n\n  .highlight-toast.success {\n    background-color: #4caf50;\n  }\n\n  .highlight-toast.error {\n    background-color: #f44336;\n  }\n\n  .highlight-toast.processing {\n    background-color: #2196f3;\n  }\n  `;\ndocument.head.appendChild(style);\n// Create toast container\nconst toastContainer = document.createElement('div');\ntoastContainer.className = 'highlight-toast-container';\ndocument.body.appendChild(toastContainer);\n// Toast notification function\nfunction showToast(message, type = 'processing', duration = 3000) {\n    const toast = document.createElement('div');\n    toast.className = `highlight-toast ${type}`;\n    toast.textContent = message;\n    toastContainer.appendChild(toast);\n    if (duration > 0) {\n        setTimeout(() => {\n            toast.style.animation = 'fadeOut 0.3s ease-in forwards';\n            setTimeout(() => {\n                toastContainer.removeChild(toast);\n            }, 300);\n        }, duration);\n    }\n    return toast;\n}\n;\ndocument.head.appendChild(style);\n// Get all text nodes within an element\nfunction getTextNodes(element) {\n    const textNodes = [];\n    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);\n    let node;\n    while (node = walker.nextNode()) {\n        textNodes.push(node);\n    }\n    return textNodes;\n}\nfunction extractJSONFromResponse(content) {\n    try {\n        console.debug('Raw response content:', content);\n        if (typeof content === 'string' && content.includes('\"content\":')) {\n            try {\n                const parsed = JSON.parse(content);\n                if (parsed.choices?.[0]?.message?.content) {\n                    content = parsed.choices[0].message.content.trim();\n                    console.debug('Extracted content from OpenAI response:', content);\n                }\n            }\n            catch (e) {\n                console.debug('Failed to parse OpenAI response format:', e);\n            }\n        }\n        const arrayMatch = content.match(/\\[\\s*{[^]*}\\s*\\]/g);\n        if (arrayMatch) {\n            content = arrayMatch[0];\n            console.debug('Extracted JSON array string:', content);\n        }\n        const parsed = JSON.parse(content);\n        if (!Array.isArray(parsed)) {\n            throw new Error('Response is not an array');\n        }\n        parsed.forEach((highlight, index) => {\n            if (!highlight || typeof highlight !== 'object') {\n                throw new Error(`Invalid highlight at index ${index}: not an object`);\n            }\n            if (!highlight.text || typeof highlight.text !== 'string') {\n                throw new Error(`Invalid highlight at index ${index}: text must be a string`);\n            }\n            if (highlight.text.trim().length === 0) {\n                throw new Error(`Invalid highlight at index ${index}: text cannot be empty`);\n            }\n        });\n        return parsed;\n    }\n    catch (e) {\n        console.error('JSON extraction failed:', e);\n        const errorMessage = e instanceof Error ? e.message : 'Unknown error';\n        throw new Error(`Failed to extract valid JSON: ${errorMessage}`);\n    }\n}\nasync function processQueue() {\n    if (isProcessingQueue)\n        return;\n    isProcessingQueue = true;\n    try {\n        while (requestQueue.length > 0) {\n            const request = requestQueue[0];\n            if (request) {\n                try {\n                    await request();\n                    requestQueue.shift(); // Only remove the request after it's completed\n                    // Wait for rate limit after each successful request\n                    await new Promise(resolve => setTimeout(resolve, API_RATE_LIMIT));\n                }\n                catch (error) {\n                    console.error('Error processing queue item:', error);\n                    requestQueue.shift(); // Remove failed request to prevent blocking\n                    // Still wait for rate limit even after failure to prevent rapid retries\n                    await new Promise(resolve => setTimeout(resolve, API_RATE_LIMIT));\n                }\n            }\n        }\n    }\n    finally {\n        isProcessingQueue = false;\n    }\n}\nasync function processElement(element) {\n    // Skip if highlighting is disabled\n    if (!isHighlightingEnabled) {\n        return;\n    }\n    // Get text content\n    const textNodes = getTextNodes(element);\n    const text = textNodes.map(node => node.textContent).join(' ');\n    const elementId = element.getAttribute('data-highlight-id') || `highlight-${Math.random().toString(36).substr(2, 9)}`;\n    element.setAttribute('data-highlight-id', elementId);\n    // Get the last processed position for this element\n    const lastPosition = lastProcessedPosition.get(elementId) || 0;\n    if (lastPosition >= text.length) {\n        processedElements.add(element);\n        return;\n    }\n    // Process the next fragment\n    const fragmentSize = 1000; // Adjust this value based on your needs\n    const start = lastPosition;\n    const end = Math.min(start + fragmentSize, text.length);\n    const fragment = text.slice(start, end);\n    // Check cache first\n    const cacheKey = `${elementId}-${start}-${end}`;\n    if (highlightCache.has(cacheKey)) {\n        applyHighlights(element, textNodes, highlightCache.get(cacheKey));\n        lastProcessedPosition.set(elementId, end);\n        if (end >= text.length) {\n            processedElements.add(element);\n        }\n        return;\n    }\n    // Add request to queue\n    return new Promise((resolve, reject) => {\n        requestQueue.push(async () => {\n            try {\n                if (!isHighlightingEnabled) {\n                    resolve();\n                    return;\n                }\n                await processElementRequest(element, fragment, textNodes, start);\n                lastProcessedPosition.set(elementId, end);\n                if (end >= text.length) {\n                    processedElements.add(element);\n                }\n                else {\n                    // Process next fragment after current one is complete\n                    await processElement(element);\n                }\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n        processQueue();\n    });\n}\nasync function retryFetch(url, options, retries = MAX_RETRIES) {\n    try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n            throw new Error(`API request failed: ${response.statusText}`);\n        }\n        return response;\n    }\n    catch (error) {\n        if (retries > 0) {\n            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n            return retryFetch(url, options, retries - 1);\n        }\n        throw error;\n    }\n}\nasync function processElementRequest(element, text, textNodes, startOffset = 0) {\n    let processingToast = null;\n    try {\n        processingToast = showToast('Processing highlights...', 'processing', 0);\n        const response = await retryFetch(`${settings.baseUrl}/v1/chat/completions`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${settings.apiKey}`\n            },\n            body: JSON.stringify({\n                model: settings.model,\n                messages: [{\n                        role: 'system',\n                        content: settings.prompt\n                    }, {\n                        role: 'user',\n                        content: text\n                    }]\n            })\n        });\n        let data;\n        try {\n            data = await response.json();\n            console.log('API Response:', data);\n        }\n        catch (error) {\n            console.error('Response parsing error:', error);\n            throw new Error('Failed to parse API response as JSON');\n        }\n        if (!data.choices?.[0]?.message?.content) {\n            throw new Error('Invalid API response: missing required fields');\n        }\n        const highlights = extractJSONFromResponse(data.choices[0].message.content);\n        if (!Array.isArray(highlights)) {\n            throw new Error('Invalid highlights format');\n        }\n        // Update cache\n        const elementId = element.getAttribute('data-highlight-id');\n        const cacheKey = `${elementId}-${startOffset}-${startOffset + text.length}`;\n        if (highlightCache.size >= MAX_CACHE_SIZE) {\n            const firstKeyResult = highlightCache.keys().next();\n            if (!firstKeyResult.done && firstKeyResult.value) {\n                highlightCache.delete(firstKeyResult.value);\n            }\n        }\n        highlightCache.set(cacheKey, highlights);\n        // Apply highlights\n        applyHighlights(element, textNodes, highlights);\n        // Show success toast\n        if (processingToast) {\n            toastContainer.removeChild(processingToast);\n        }\n        showToast('Highlights applied successfully!', 'success');\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        console.error('Failed to process element:', errorMessage);\n        element.setAttribute('data-highlight-error', errorMessage);\n        // Show error toast\n        if (processingToast) {\n            toastContainer.removeChild(processingToast);\n        }\n        showToast(`Error: ${errorMessage}`, 'error');\n        throw error;\n    }\n}\nlet processedRanges = new Set();\nfunction applyHighlights(element, textNodes, highlights) {\n    if (!textNodes.length)\n        return;\n    // Create a unique identifier for the element\n    const elementId = element.getAttribute('data-highlight-id') || `highlight-${Math.random().toString(36).substr(2, 9)}`;\n    element.setAttribute('data-highlight-id', elementId);\n    // Create or get the wrapper element\n    let wrapper = element.parentElement?.querySelector('.highlight-wrapper');\n    if (!wrapper) {\n        wrapper = document.createElement('div');\n        wrapper.className = 'highlight-wrapper';\n        wrapper.style.position = 'relative';\n        element.parentNode?.insertBefore(wrapper, element);\n        wrapper.appendChild(element);\n    }\n    // Store highlight data in local storage with URL-based key\n    const pageUrl = window.location.href;\n    const storageKey = `highlight-data-${pageUrl}-${elementId}`;\n    const highlightData = {\n        text: textNodes.map(node => node.textContent).join(' '),\n        highlights: highlights,\n        timestamp: Date.now(),\n        url: pageUrl\n    };\n    try {\n        chrome.storage.local.set({ [storageKey]: highlightData });\n    }\n    catch (error) {\n        console.error('Failed to store highlight data:', error);\n    }\n    // Create a document fragment to batch DOM operations\n    const fragment = document.createDocumentFragment();\n    const range = document.createRange();\n    highlights.forEach(({ text }, index) => {\n        try {\n            // Generate a unique key for this text range\n            const rangeKey = `${elementId}-${text}`;\n            // Skip if this range has already been processed\n            if (processedRanges.has(rangeKey)) {\n                return;\n            }\n            // Find the text in the document\n            const fullText = textNodes.map(node => node.textContent).join(' ');\n            const exactMatch = fullText.indexOf(text);\n            let match = exactMatch !== -1\n                ? { start: exactMatch, end: exactMatch + text.length }\n                : TextMatcher.findBestMatch(fullText, Math.max(0, exactMatch - 50), Math.min(fullText.length, exactMatch + text.length + 50));\n            if (!match) {\n                console.warn(`Could not find reliable match for text:`, { text });\n                return;\n            }\n            // Find the correct text nodes for the match\n            let currentPos = 0;\n            let startNode = null;\n            let endNode = null;\n            let startOffset = 0;\n            let endOffset = 0;\n            for (const node of textNodes) {\n                const nodeLength = (node.textContent || '').length;\n                const nodeEnd = currentPos + nodeLength;\n                if (!startNode && match.start <= nodeEnd) {\n                    startNode = node;\n                    startOffset = match.start - currentPos;\n                }\n                if (!endNode && match.end <= nodeEnd) {\n                    endNode = node;\n                    endOffset = match.end - currentPos;\n                    break;\n                }\n                currentPos += nodeLength;\n            }\n            if (!startNode || !endNode) {\n                console.warn(`Could not find valid text nodes for text:`, { text });\n                return;\n            }\n            // Create highlight element\n            range.setStart(startNode, startOffset);\n            range.setEnd(endNode, endOffset);\n            const rects = range.getClientRects();\n            const wrapperRect = wrapper.getBoundingClientRect();\n            Array.from(rects).forEach(rect => {\n                if (rect.width === 0 || rect.height === 0)\n                    return;\n                const highlight = document.createElement('div');\n                highlight.className = 'text-highlight';\n                highlight.setAttribute('data-highlight-id', elementId);\n                highlight.style.position = 'absolute';\n                highlight.style.backgroundColor = settings.highlightColor || '#FFEB3B';\n                highlight.style.opacity = '0.5';\n                highlight.style.pointerEvents = 'none';\n                highlight.style.zIndex = '-1';\n                highlight.style.animation = `highlightFade ${settings.animationSpeed || 0.5}s ease-in-out`;\n                // Calculate position relative to the wrapper's viewport-relative position\n                const rectTop = rect.top + window.scrollY;\n                const rectLeft = rect.left + window.scrollX;\n                const wrapperTop = wrapperRect.top + window.scrollY;\n                const wrapperLeft = wrapperRect.left + window.scrollX;\n                highlight.style.left = `${rectLeft - wrapperLeft}px`;\n                highlight.style.top = `${rectTop - wrapperTop}px`;\n                highlight.style.width = `${rect.width}px`;\n                highlight.style.height = `${rect.height}px`;\n                fragment.appendChild(highlight);\n            });\n            // Mark this range as processed\n            processedRanges.add(rangeKey);\n        }\n        catch (error) {\n            console.error(`Error applying highlight at index ${index}:`, error);\n        }\n    });\n    // Batch append all highlights\n    wrapper.appendChild(fragment);\n}\nfunction initializeObserver() {\n    observer = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting && entry.target instanceof HTMLElement) {\n                processElement(entry.target).catch(error => {\n                    console.error('Failed to process element:', error);\n                });\n            }\n        });\n    }, {\n        threshold: 0.1,\n        rootMargin: '50px'\n    });\n}\n// Initialize the content script\nasync function initialize() {\n    try {\n        // Get settings from storage\n        const { highlightSettings: result } = await chrome.storage.sync.get({\n            highlightSettings: {\n                apiKey: '',\n                baseUrl: 'https://api.openai.com',\n                model: 'gpt-3.5-turbo',\n                presetPrompt: 'important',\n                customPrompt: '',\n                prompt: 'IMPORTANT: You must follow these rules exactly:\\n1. Return ONLY a JSON array of objects\\n2. Each object must have three properties:\\n   - text: the exact text content to highlight\\n   - start: approximate start index (number)\\n   - end: approximate end index (number)\\n3. Format must be: [{\\\"text\\\": string, \\\"start\\\": number, \\\"end\\\": number}]',\n                theme: 'light',\n                animationSpeed: 0.5,\n                highlightColor: '#FFEB3B'\n            }\n        });\n        settings = result;\n        if (!settings.apiKey) {\n            console.warn('API key not set. Please configure in extension options.');\n            return;\n        }\n        // Check if current site is whitelisted\n        const currentHost = window.location.hostname;\n        const { whitelistedSites = [] } = await chrome.storage.sync.get({ whitelistedSites: [] });\n        const isWhitelisted = whitelistedSites.includes(currentHost);\n        if (!isWhitelisted) {\n            console.log('Site not whitelisted. Waiting for manual activation.');\n            return;\n        }\n        // Automatically enable highlighting for whitelisted sites\n        isHighlightingEnabled = true;\n        initializeObserver();\n        // Load cached highlights first using URL-based cache key\n        const pageUrl = window.location.href;\n        const contentElements = document.querySelectorAll('p, article, section, .content, main');\n        // Try to load all cached highlights for this page\n        try {\n            const allCacheKeys = await chrome.storage.local.get(null);\n            const pageCacheEntries = Object.entries(allCacheKeys).filter(([key]) => key.startsWith(`highlight-data-${pageUrl}-`));\n            // Process each element\n            for (const element of contentElements) {\n                if (element instanceof HTMLElement) {\n                    const elementId = element.getAttribute('data-highlight-id') ||\n                        `highlight-${Math.random().toString(36).substr(2, 9)}`;\n                    element.setAttribute('data-highlight-id', elementId);\n                    // Look for cached data for this element\n                    const storageKey = `highlight-data-${pageUrl}-${elementId}`;\n                    const cachedEntry = pageCacheEntries.find(([key]) => key === storageKey);\n                    if (cachedEntry) {\n                        const [_, cachedData] = cachedEntry;\n                        if (cachedData && cachedData.highlights) {\n                            const textNodes = getTextNodes(element);\n                            applyHighlights(element, textNodes, cachedData.highlights);\n                            processedElements.add(element);\n                            continue;\n                        }\n                    }\n                    // Only observe elements that don't have cached highlights\n                    if (!processedElements.has(element)) {\n                        observer.observe(element);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            console.error('Failed to load cached highlights:', error);\n            // Fall back to observing all elements if cache loading fails\n            contentElements.forEach(element => {\n                if (element instanceof HTMLElement && !processedElements.has(element)) {\n                    observer.observe(element);\n                }\n            });\n        }\n    }\n    catch (error) {\n        console.error('Failed to initialize extension:', error);\n    }\n}\n// Listen for messages from popup and background\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === 'ping') {\n        sendResponse({ status: 'alive' });\n        return true;\n    }\n    if (message.action === 'getHighlightingState') {\n        sendResponse({ isEnabled: isHighlightingEnabled });\n        return true;\n    }\n    if (message.action === 'toggleHighlight') {\n        isHighlightingEnabled = !isHighlightingEnabled;\n        if (isHighlightingEnabled) {\n            initialize();\n        }\n        else {\n            // Clear the request queue when highlighting is disabled\n            requestQueue = [];\n            isProcessingQueue = false;\n        }\n        sendResponse({ isEnabled: isHighlightingEnabled });\n        return true;\n    }\n    if (message.action === 'clearHighlights') {\n        // Remove all highlight elements\n        document.querySelectorAll('.text-highlight').forEach(el => el.remove());\n        // Clear processed elements set\n        processedElements.clear();\n        // Clear highlight cache\n        highlightCache.clear();\n        sendResponse({ status: 'success' });\n        return true;\n    }\n    if (message.action === 'whitelistUpdated') {\n        initialize();\n        sendResponse({ status: 'success' });\n        return true;\n    }\n});\n// Initialize on load\ninitialize();\n// Start the extension\ninitialize();\n"],"names":["TextMatcher","findBestMatch","text","approximateStart","approximateEnd","approximateText","slice","Math","max","min","length","searchStart","this","FUZZY_MARGIN","searchEnd","bestMatch","bestConfidence","i","candidateText","confidence","calculateSimilarity","MIN_CONFIDENCE","start","end","str1","str2","len1","len2","matrix","j","cost","settings","observer","processedElements","Set","isHighlightingEnabled","highlightCache","Map","requestQueue","isProcessingQueue","lastProcessedPosition","style","document","createElement","textContent","head","appendChild","toastContainer","showToast","message","type","duration","toast","className","setTimeout","animation","removeChild","getTextNodes","element","textNodes","walker","createTreeWalker","NodeFilter","SHOW_TEXT","node","nextNode","push","async","processElement","map","join","elementId","getAttribute","random","toString","substr","setAttribute","lastPosition","get","add","fragment","cacheKey","has","applyHighlights","set","Promise","resolve","reject","startOffset","processingToast","response","retryFetch","baseUrl","method","headers","apiKey","body","JSON","stringify","model","messages","role","content","prompt","data","json","console","log","error","Error","choices","highlights","debug","includes","parsed","parse","trim","e","arrayMatch","match","Array","isArray","forEach","highlight","index","errorMessage","extractJSONFromResponse","size","firstKeyResult","keys","next","done","value","delete","processElementRequest","request","shift","processQueue","url","options","retries","fetch","ok","statusText","processedRanges","wrapper","parentElement","querySelector","position","parentNode","insertBefore","pageUrl","window","location","href","storageKey","highlightData","timestamp","Date","now","chrome","storage","local","createDocumentFragment","range","createRange","rangeKey","fullText","exactMatch","indexOf","warn","currentPos","startNode","endNode","endOffset","nodeLength","nodeEnd","setStart","setEnd","rects","getClientRects","wrapperRect","getBoundingClientRect","from","rect","width","height","backgroundColor","highlightColor","opacity","pointerEvents","zIndex","animationSpeed","rectTop","top","scrollY","rectLeft","left","scrollX","wrapperTop","wrapperLeft","initialize","highlightSettings","result","sync","presetPrompt","customPrompt","theme","currentHost","hostname","whitelistedSites","IntersectionObserver","entries","entry","isIntersecting","target","HTMLElement","catch","threshold","rootMargin","contentElements","querySelectorAll","allCacheKeys","pageCacheEntries","Object","filter","key","startsWith","cachedEntry","find","_","cachedData","observe","runtime","onMessage","addListener","sender","sendResponse","action","status","isEnabled","el","remove","clear"],"sourceRoot":""}